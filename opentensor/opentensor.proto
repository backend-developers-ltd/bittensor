syntax = "proto3";

// Service definition for tensor processing servers.
service Opentensor {
	// Forward tensor request. 
	rpc Forward (TensorMessage) returns (TensorMessage) {}
	
	// Backward tensor request i.e. gradient.
	rpc Backward (TensorMessage) returns (TensorMessage) {}
}

// Service definition for a pow based cache for sharing opentensor synapses.
service Metagraph {
	rpc Gossip (SynapseBatch) returns (SynapseBatch) {}
}

// Batch of neuron service definitions.
message SynapseBatch {
	// SIZE: 32-bits (4-bytes)
	float version = 1;
	// Sender public_key
	string neuron_key = 2;
	// Public key signature. 
	bytes signature = 3;
	// Synapse endpoint definitions.
	// SIZE: 304-bytes * N
	repeated Synapse synapses = 4;
}


// "Synapse" or "Expert" endpoint definition.
// Fully describes a tensor processing service definition for hivemind and opentensor.
// SIZE: (256 * 4) + (512 * 2) + (128 * 3) = 2432-bits (304 bytes)
// NOTE: only the (address, port, identity) need to be stored in RAM.
// (address, port, identity) = (128 + 32 + 256) = 412 (52 bytes)
// Holding 20,000,000 endpoints in 1-GB of RAM and 6-GB of Disk.
message Synapse {
	// SIZE: 32 bits (4-bytes)
	// i.e. 1.0
	float version = 1;
	
	// Neuron key: ed25519 public key raw hex encoded. See note above.
	// Links this synapse definition to the containing neuron account on chain.
	// i.e. b'4c598ff31b68eb6c458c2dc51b25367fa213c566088077f46d93156148429d78'
	// SIZE: 256-bits (32-bytes)
	// $ python 
	// >> from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
	// >> from cryptography.hazmat.primitives import serialization
	// >> private = Ed25519PrivateKey.generate()
	// >> public = private.public_key()
	// source_id = '0x%s' % public.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw).hex()
	string neuron_key = 2;

	// UID of type ed25519 public key
	// i.e. b'4c598ff31b68eb6c458c2dc51b25367fa213c566088077f46d93156148429d78'
	// SIZE: 256-bits (32-bytes)
	// $ python 
	// >> from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey 
	// >> from cryptography.hazmat.primitives import serialization
	// >> private = Ed25519PrivateKey.generate()
	// >> public = private.public_key()
	// source_id = '0x%s' % public.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw).hex()
	string synapse_key = 3;
	
	// Synapse IP. 
  	// i.e. '0.0.0.0'
  	// TODO (const) format for ipv6 vs ipv4
	// TODO (const) format specification
	// SIZE: 128-bits (16-bytes)
	string address = 4;
	
	// Synapse listening port.
  	// i.e. '8081'
	// SIZE: 32-bits (4-bytes)
	// TODO (const) could be formated to int32, or joined with address.
	string port = 5;
  
	// Synapse indefs describing the accepted tensor shapes.
	// Tensors in TensorMessages are assumed to be packed in this order.
	// SIZE: ~128 bits (16 bytes) * n
	repeated TensorDef indef = 6;

	// Synapse outdefs describing the returned tensor shapes.
	// Tensors in TensorMessages are assumed to be packed in this order.
	// NOTE: When passing in gradient in reverse, inputs and gradients are assumed to be packed: 
	// [input_1, gradient_1, input_2, gradient_2, input_3 ... ]
	// SIZE: ~128 bits (16 bytes) * n
	repeated TensorDef outdef = 7;

	// Optional: Hash of block during message creation.
	// Links the POW to a global-time protecting the cache from
	// long range POW attacks.
	// SIZE: 512-bits (64-bytes)
	// NOTE: hashes are likely to change from bitcoin to bittensor.
	// $ python
	// >> import requests
	// >> block_hash = requests.get('https://blockchain.info/latestblock').json()['hash']
	// >> height = requests.get('https://blockchain.info/rawblock/$block_hash').json()['height']
	// >> work_by_time = difficulty(proof_of_work) / (height_now - height_of_msg) 
	string block_hash = 8;

	// Optional nounce value: used for proof of work generation.
	// SIZE: 32-bits (4-bytes)
	int32 nounce = 9;

	// Optional: Sha256 proof of work used to preferentially keep 
	// this definition in the cache.
	// SIZE: 256-bits (32-bytes)
	// >>> from cryptography.hazmat.backends import default_backend
	// >>> from cryptography.hazmat.primitives import hashes
	// >>> nounce = 0
	// >>> do {
	// >>> 	nounce += 1
	// >>> 	digest = hashes.Hash(hashes.SHA1(), backend=default_backend())
	// >>> 	digest.update(neuron_key.encode('utf-8'))
  	// >>> 	digest.update(address.encode('utf-8'))
  	// >>> 	digest.update(port.encode('utf-8))
  	// >>> 	digest.update(indef.SerializeToString().encode('utf-8))
	// >>> 	digest.update(oudef.SerializeToString().encode('utf-8))
	// >>> 	digest.update(block_hash)
  	// >>> 	digest.update(bytes(nounce))
	// >>> 	digest = digest.finalize()
	// >>> while( count_zeros(digest) < difficulty )
	// >>> proof_of_work = digest
	bytes proof_of_work = 10;
  
  	// Signature: ed25519 public_key signature which signs
	// this synapse definition using the attached neuron_key.
	// SIZE: 512-bits (64-bytes)
  	// $ python
	// signature = private_key.sign(digest) # to create.
	// >>> source_key.verify(signature, digest) # to verify.
	bytes signature = 11;

	// TODO(const): remove this item
	string m_port = 12;
}	

// TensorMessage
// Contains a payload of 1 or more serialized tensors and their definitions.
// Also contains information to identity and verify the sender. 
// Protocol for opentensor-hivemind message passing.
// SIZE: 136 bytes + (tensor_size)
message TensorMessage {
	// version: protocol version 
	// i.e. 1.0
	// 32-bits (4-bytes)
	float version = 1;

	// neuron key: neuron identifier of calling neuron. 
	// TYPE: raw hex encoded ed25519 public key. See note above.
  	// Links this synapse definition to the containing neuron account on chain.
  	// i.e. b'4c598ff31b68eb6c458c2dc51b25367fa213c566088077f46d93156148429d78'
	// SIZE: 256-bits (32-bytes)
  	// $ python 
	// >> from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
	// >> from cryptography.hazmat.primitives import serialization
	// >> private = Ed25519PrivateKey.generate()
	// >> public = private.public_key()
	// source_id = '0x%s' % public.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw).hex()
	string neuron_key = 2;

	// synapse key: UID of synapse to call on the recieving neuron. 
	// TYPE: raw hex encoded ed25519 public key.
	// i.e. b'4c598ff31b68eb6c458c2dc51b25367fa213c566088077f46d93156148429d78'
	// SIZE: 256-bits (32-bytes)
  	// $ python 
  	// >> from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey 
  	// >> from cryptography.hazmat.primitives import serialization
  	// >> private = Ed25519PrivateKey.generate()
  	// >> public = private.public_key()
  	// source_id = '0x%s' % public.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw).hex()
	string synapse_key = 3;

	// nounce: [OPTIONAL] int to identify message ordering and signature updates.
	// >> nounce = nounce + 1
	// SIZE: 32-bits (4-bytes)
	int64 nounce = 4;

	// signature: [OPTIONAL] digital signature linking the nounce, neuron_key and synapse_key
	// prevents spoofing attacks where an adversary attempts to send messages as other peers.
	// for a unique nounce only the private key holder can create a valid signature.
	// NOTE: this field does not link the signature to the inputs. New signatures do not need
	// to be generated for each message.
	// $ python
	// >>> from cryptography.hazmat.backends import default_backend
	// >>> from cryptography.hazmat.primitives import hashes
	// >>> digest = hashes.Hash(hashes.SHA1(), backend=default_backend())
	// >>> digest.update(neuron_key.encode('utf-8'))
	// >>> digest.update(synapse_key.encode('utf-8'))
	// >>> digest.update(bytes(nounce))
	// >>> digest = digest.finalize()
	// signature = private_key.sign(digest) # to create.
	// >>> neuron_key.verify(signature, digest) # to verify.
	bytes signature = 5;

	// tensors: 1 or more tensors passed on the wire.
	// SIZE: variable.
	// NOTE: These tensors should be packed in the same order as that described in the synapse.tensor_def
	// NOTE: During backward calls the tensors should be ordered [input_1, input_2, ... grad_1, grad_2, ...] 
	repeated Tensor tensors = 6;
}

// A serialized tensor object of any type created using the opentensor.serializer class.
message Tensor {
	// version: protocol version 
	// i.e. 1.0
	// 32-bits (4-bytes)
	float version = 1;

	// buffer: Serialized raw tensor content. This representation
  	// can be used for all tensor types. The purpose of this representation is to
  	// reduce serialization overhead during RPC calls by avoiding serialization of
  	// many repeated small items. In other words, we just copy the bytes and let
	// the application layer serialize and deserialize the bytes. 
  	// e.g.
	// 1. PyTorchSerialzier.serialize(torch.Tensor) --> opentensor_pb2.Tensor
	// 2. PyTorchSerializer.deserialize(opentensor_pb2.Tensor) --> torch.Tensor    	
	bytes buffer = 2;

	// Shape and type information describing how the bytest buffer should be interpreted. 
	TensorDef tensor_def = 3;
}


// A tensor description used to define input and output schemas,
// As well as to describe passed tensors.
// SIZE: ~ 28 bytes.
message TensorDef {	
	// version: protocol version 
	// i.e. 1.0
	// 32-bits (4-bytes)
	float version = 1;
	
	// shape: the shape of this tensor.
	// NOTE: The batch dimension is assumed here. 
	// i.e. [256, 724] -> [-1, 256, 724]
	// ~ 5 * int32 = 128 bits - (16 bytes)
	repeated int64 shape = 3;
    	
	// dtype: the tensor datatype.
	// int32 32-bits (4-bytes)
	DataType dtype = 4;

	// Does this tensor require a gradient.
	// 1 bit.
	bool requires_grad = 5;
}

// dtype: the tensor datatype.
// int32 32-bits (4-bytes)
enum DataType {
	UNKNOWN = 0;
	FLOAT32 = 1;
	FLOAT64 = 2;
	INT32 = 3;
	INT64 = 4;
}