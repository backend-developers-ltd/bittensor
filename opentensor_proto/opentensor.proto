syntax = "proto3";

service Opentensor {
	// Forward tensor request. 
	rpc Fwd(TensorMessage) returns (TensorMessage) {}
	
	// Reverse tensor (gradient) request.
	rpc Bwd(TensorMessage) returns (TensorMessage) {}
}

// Proto for a opentensor.
message TensorMessage {
	// Protocol version: i.e. 1.0
	float version = 1;

	// Source ed25519 publickey raw encoded and interpreted as a string:
	// i.e. "0x4c598ff31b68eb6c458c2dc51b25367fa213c566088077f46d93156148429d78"
  	// $ python 
	// >> from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
	// >> from cryptography.hazmat.primitives import hashes, serialization
	// >> private = Ed25519PrivateKey.generate()
	// >> public = private.public_key()
	// >> id = '0x%s' % public.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw).hex()
	bytes public_key = 2;

	// Message Nounce: A random or incrementing digit.
	// i.e. bytes(1223123)
	bytes nounce = 3;
	
	// Tensor content: Raw encoded tensor bytes.
	// Serialized raw tensor content. This representation
  	// can be used for all tensor types. The purpose of this representation is to
  	// reduce serialization overhead during RPC call by avoiding serialization of
  	// many repeated small items.
	// TODO(const) decide on encoding method.
	// 1. opentensor.encoding(numpy_array) --> bytes
	// 2. opentensor.encoding(tensor) --> bytes
	bytes content = 4;

	// Sha256 message digest from (nounce, publikey, content)
	// $ python
	// >>> from cryptography.hazmat.backends import default_backend
	// >>> from cryptography.hazmat.primitives import hashes
	// >>> digest = hashes.Hash(hashes.SHA256(), backend=default_backend())
	// >>> digest.update(nounce)
	// >>> digest.update(bytes(source_id))
	// >>> digest.update(payload)
	// >>> digest = digest.finalize()
	// i.e digest = b'l\xa1=R\xcap\xc8\x83\xe0\xf0\xbb\x10\x1eBZ\x89\xe8bM\xe5\x1d\xb2\xd29%\x93\xafj\x84\x11\x80\x90'
	bytes digest = 5;

	// $ python
	// >> (client) signature = private_key.sign(digest)
	// >> (server side) public_key.verify(signature, digest))
	bytes signature = 6;

	// Tensorshape: Shape of the tensor, for interpreting the payload.
	TensorShapeProto shape = 7;
	
	// Dtype: tensor type information.
	DataType dtype = 8;
}

// Pulled from: "tensorflow/core/framework/tensor_shape.proto"
// Dimensions of a tensor.
message TensorShapeProto {
  // One dimension of the tensor.
  message Dim {
    // Size of the tensor in that dimension.
    // This value must be >= -1, but values of -1 are reserved for "unknown"
    // shapes (values of -1 mean "unknown" dimension).  Certain wrappers
    // that work with TensorShapeProto may fail at runtime when deserializing
    // a TensorShapeProto containing a dim value of -1.
    int64 size = 1;

    // Optional name of the tensor dimension.
    string name = 2;
  };

  // The order of entries in "dim" matters: It indicates the layout of the
  // values in the tensor in-memory representation.
  //
  // The first entry in "dim" is the outermost dimension used to layout the
  // values, the last entry is the innermost dimension.  This matches the
  // in-memory layout of RowMajor Eigen tensors.
  repeated Dim dim = 2;

  // If true, the number of dimensions in the shape is unknown.
  //
  // If true, "dim.size()" must be 0.
  bool unknown_rank = 3;
};

// Pulled from: tensorflow/core/framework/types.proto
enum DataType {
  // Not a legal value for DataType.  Used to indicate a DataType field
  // has not been set.
  DT_INVALID = 0;

  // Data types that all computation devices are expected to be
  // capable to support.
  DT_FLOAT = 1;
  DT_DOUBLE = 2;
  DT_INT32 = 3;
  DT_UINT8 = 4;
  DT_INT16 = 5;
  DT_INT8 = 6;
  DT_STRING = 7;
  DT_COMPLEX64 = 8;  // Single-precision complex
  DT_INT64 = 9;
  DT_BOOL = 10;
  DT_QINT8 = 11;     // Quantized int8
  DT_QUINT8 = 12;    // Quantized uint8
  DT_QINT32 = 13;    // Quantized int32
  DT_BFLOAT16 = 14;  // Float32 truncated to 16 bits.  Only for cast ops.
  DT_QINT16 = 15;    // Quantized int16
  DT_QUINT16 = 16;   // Quantized uint16
  DT_UINT16 = 17;
  DT_COMPLEX128 = 18;  // Double-precision complex
  DT_HALF = 19;
  DT_RESOURCE = 20;
  DT_VARIANT = 21;  // Arbitrary C++ data types
  DT_UINT32 = 22;
  DT_UINT64 = 23;
}

