syntax = "proto3";

service Opentensor {
	// Forward tensor request. 
	rpc Fwd(TensorMessage) returns (TensorMessage) {}
	
	// Reverse tensor (gradient) request.
	rpc Bwd(TensorMessage) returns (TensorMessage) {}
}

// Proto for a opentensor.
message TensorMessage {
	// version: protocol version 
	// i.e. 1.0
	float version = 1;

	// sender_id: raw bytes representation of the source's ed25519 public key.
	// i.e. b'4c598ff31b68eb6c458c2dc51b25367fa213c566088077f46d93156148429d78'
  	// $ python 
	// >> from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
	// >> from cryptography.hazmat.primitives import serialization
	// >> private = Ed25519PrivateKey.generate()
	// >> public = private.public_key()
	// source_id = '0x%s' % public.public_bytes(serialization.Encoding.Raw, serialization.PublicFormat.Raw).hex()
	string source_id = 2;

	// target_key: raw bytes representation of the target's ed25519 public key
	// Note that clients and experts both have ed25519 public keys. So the response tensor message
	// should simply have these two keys swapped.
	string target_id = 3;

	// nounce: random bytes to identify this message.
	// >> nounce = os.urandom(12)
	bytes nounce = 4;

	// signature: digital signature linking the nounce and source_key
	// prevents spoofing attacks where an adversary attempts to send messages as other peers.
	// $ python
	// >>> from cryptography.hazmat.backends import default_backend
	// >>> from cryptography.hazmat.primitives import hashes
	// >>> digest = hashes.Hash(hashes.SHA1(), backend=default_backend())
	// >>> digest.update(msg.source_key)
	// >>> digest.update(msg.nounce)
	// >>> digest = digest.finalize()
	// >>> source_key.verify(msg.signature, digest)
	bytes signature = 5;

	// tensor: 0 or more tensors passed on the wire.
	repeated Tensor tensors = 6;
}

message Tensor {
	// Tensor content: Serialized raw tensor content. This representation
  	// can be used for all tensor types. The purpose of this representation is to
  	// reduce serialization overhead during RPC call by avoiding serialization of
  	// many repeated small items. In other words, we just copy the bytes and let
	// the application layer serialize and deserialize the bytes. 
	// 1. opentensor.serialize(numpy_array) --> buffer
	// 2. opentensor.deserialize(bytes_content) --> numpy_array    	
	bytes buffer = 1;
   	
	// shape: the shape of this tensor.
	// i.e. [256, 724]
	repeated uint32 shape = 2;
    	
	// TODO(const) Agree to the significance of this bool.
	bool requires_grad = 3;
    
	// dtype: the tensor datatype.	
	DataType dtype = 4;
}

// Pulled from: tensorflow/core/framework/types.proto
enum DataType {
  // has not been set.
  DT_INVALID = 0;

  // Data types that all computation devices are expected to be
  // capable to support.
  DT_FLOAT = 1;
  DT_DOUBLE = 2;
  DT_INT32 = 3;
  DT_UINT8 = 4;
  DT_INT16 = 5;
  DT_INT8 = 6;
  DT_STRING = 7;
  DT_COMPLEX64 = 8;  // Single-precision complex
  DT_INT64 = 9;
  DT_BOOL = 10;
  DT_QINT8 = 11;     // Quantized int8
  DT_QUINT8 = 12;    // Quantized uint8
  DT_QINT32 = 13;    // Quantized int32
  DT_BFLOAT16 = 14;  // Float32 truncated to 16 bits.  Only for cast ops.
  DT_QINT16 = 15;    // Quantized int16
  DT_QUINT16 = 16;   // Quantized uint16
  DT_UINT16 = 17;
  DT_COMPLEX128 = 18;  // Double-precision complex
  DT_HALF = 19;
  DT_RESOURCE = 20;
  DT_VARIANT = 21;  // Arbitrary C++ data types
  DT_UINT32 = 22;
  DT_UINT64 = 23;
}

